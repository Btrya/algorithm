## 单串
单串 dp[i] 线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 `dp[i] := 考虑[0...i]` 上，原问题的解，其中 i 位置的处理，根据不同的问题，主要有两种方式：
- 第一种是 i 位置必须取，此时状态可以进一步描述为 `dp[i] := 考虑 [0..i] 上，且取 i，原问题的解`;
- 第二种是 i 位置可以取可以不取;

大部分的问题，对 i 位置的处理是第一种方式，例如力扣：
- 70 爬楼梯问题
- 801 使序列递增的最小交换次数
- 790 多米诺和托米诺平铺
- 746 使用最小话费爬楼梯

线性动态规划中单串 dp[i] 的问题，状态的推导方向以及推导公式如下
![Image text](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/06/2-2-1.png)

1. 依赖比 i 小的 O(1) 个子问题
`dp[n]`只与常数个小规模子问题有关，状态的推导过程 `dp[i] = f(dp[i - 1], dp[i - 2], ...)`。时间复杂度O(n),空间复杂度O(n)可以优化为O(1),例如上面提到的 70，801，790，746 都属于这类。
如图所示，虽然绿色部分的 `dp[i - 1], dp[i - 2], ... , dp[0]` 均已计算过，但计算橙色的当前状态时，仅用到 `dp[i - 1]`,这属于比 i 小的O(1)个子问题。
例如，当 `f(dp[i - 1], ...) = dp[i - 1] + nums[i]` 时，当前状态 `dp[i]` 仅与 `dp[i - 1]` 有关。这个例子是一种数据结构前缀和的状态计算方式，关于前缀和的详细内容请参考下一章。 